# ERC20 Token Specification
## Contract Name
MyToken
## Security Requirements
- Access control: Only owner can mint new tokens
- State invariant: Total supply equals sum of all balances
- No reentrancy vulnerabilities possible
- No overflow/underflow vulnerabilities (use SafeMath or Solidity 0.8+)
- Transfer events must be emitted for all balance changes
## Function: constructor(string name, string symbol)
- **Description**: Initialize the ERC20 token with name and symbol
- **Precondition**: Called once during deployment
- **Postcondition**: Token name and symbol are set
- **Security**: Public, no restrictions
- **Returns**: None
## Function: mint(address to, uint256 amount)
- **Description**: Create new tokens and assign them to an address
- **Precondition**: Caller must be the contract owner
- **Postcondition**: Balance of `to` increases by `amount`, totalSupply increases by `amount`
- **Security**: Only owner can call (onlyOwner modifier required)
- **Events**: Emit Transfer(address(0), to, amount)
- **Returns**: bool success
## Function: transfer(address to, uint256 amount)
- **Description**: Transfer tokens from caller to recipient
- **Precondition**: Caller must have balance >= amount, recipient address != 0x0
- **Postcondition**: Caller balance decreases by amount, recipient balance increases by amount
- **Security**: Public, sender must have sufficient balance
- **Events**: Emit Transfer(msg.sender, to, amount)
- **Returns**: bool success
## Function: approve(address spender, uint256 amount)
- **Description**: Approve spender to transfer tokens on behalf of caller
- **Precondition**: Caller is token holder
- **Postcondition**: Spender allowance is set to amount
- **Security**: Public, any token holder can approve
- **Events**: Emit Approval(msg.sender, spender, amount)
- **Returns**: bool success
## Function: transferFrom(address from, address to, uint256 amount)
- **Description**: Transfer tokens on behalf of another address using allowance
- **Precondition**: Caller has allowance >= amount from `from` address, from has balance >= amount
- **Postcondition**: From balance decreases by amount, to balance increases by amount, allowance decreases by amount
- **Security**: Uses allowance mechanism, validates allowance before transfer
- **Events**: Emit Transfer(from, to, amount)
- **Returns**: bool success
## State Variables
- `mapping(address => uint256) balances` - Token balances for each address
- `mapping(address => mapping(address => uint256)) allowances` - Approved spending allowances
- `uint256 totalSupply` - Total token supply
- `string name` - Token name
- `string symbol` - Token symbol
- `address owner` - Contract owner (can mint)
## Events
- `Transfer(address indexed from, address indexed to, uint256 value)` - Emitted on token transfers
- `Approval(address indexed owner, address indexed spender, uint256 value)` - Emitted on approvals
## State Invariants
- `totalSupply == sum(balances[all addresses])`
- `allowances[owner][spender] >= 0`
- `balances[address] >= 0` (enforced by Solidity 0.8+)